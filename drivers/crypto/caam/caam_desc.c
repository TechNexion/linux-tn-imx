// SPDX-License-Identifier: GPL-2.0
/*
 * Descriptors for CAAM:
 *  - red/black key
 *  - encapsulation/decapsulation in blob
 *
 * Copyright 2018 NXP
 */

#include "caam.h"
#include "desc.h"
#include "caam_desc.h"
#include "desc_constr.h"

#define INITIAL_DESCSZ 16	/* size of tmp buffer for descriptor const. */

/*
 * Construct a black key conversion job descriptor
 *
 * This function constructs a job descriptor capable of performing
 * a key blackening operation on a plaintext secure memory resident object.
 *
 * - desc	pointer to a pointer to the descriptor generated by this
 *		function. Caller will be responsible to kfree() this
 *		descriptor after execution.
 * - key	physical pointer to the plaintext, which will also hold
 *		the result. Since encryption occurs in place, caller must
 *              ensure that the space is large enough to accommodate the
 *              blackened key
 * - keysz	size of the plaintext
 * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
 *		use KEY_COVER_ECB.
 *
 * Cleanup: The descriptor must be freed
 */
int cnstr_black_key_jobdesc(u32 **desc, caam_dma_addr_t key, size_t key_length,
			    caam_dma_addr_t cover_key, size_t cover_key_length,
			    u8 auth, u8 trusted_key)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u16 dsize, idx;
	u32 key_length_for_desc = key_length;

	/* Trusted key not supported */
	if (trusted_key != UNTRUSTED_KEY)
		return 0;

	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
	idx = 1;

	/*
	 * KEY commands seems limited to 32 bytes, so we should use the load
	 * command instead which can load up to 64 bytes.
	 * The size must also be loaded.
	 *
	 * TODO: The KEY command indicate it should be able to load key bigger
	 * than 32bytes but it doesn't work in practice
	 *
	 * TODO: The LOAD command indicate it should be able to load up to 96
	 * byte keys it doesn't work in practice ans is limited to 64 bytes
	 */

	/* Load key to class 1 key register */
	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_SRCDST_BYTE_KEY |
			 key_length_for_desc;
	tmpdesc[idx++] = (uintptr_t)key;
	/* Load the size of the key */
	tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_1_CCB | LDST_IMM |
			 LDST_SRCDST_WORD_KEYSZ_REG |
			 sizeof(key_length_for_desc);
	tmpdesc[idx++] = key_length_for_desc;

	/* ...and write back out via FIFO store*/
	tmpdesc[idx] = CMD_FIFO_STORE | CLASS_1 |
		       (cover_key_length & KEY_LENGTH_MASK);

	/* plus account for ECB/CCM option in FIFO_STORE */
	if (auth == KEY_COVER_ECB)
		tmpdesc[idx] |= FIFOST_TYPE_KEY_KEK;
	else
		tmpdesc[idx] |= FIFOST_TYPE_KEY_CCM_JKEK;

	idx++;
	tmpdesc[idx++] = (uintptr_t)cover_key;

	/* finish off the job header */
	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
	dsize = idx * sizeof(u32);

	/* now allocate execution buffer and coat it with executable */
	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return 0;

	memcpy(tdesc, tmpdesc, dsize);
	*desc = tdesc;

#ifdef DEBUG
	print_hex_dump(KERN_ERR, "cover desc:",
		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
#endif

	return dsize;
}
EXPORT_SYMBOL(cnstr_black_key_jobdesc);

/*
 * Construct a black key using RNG job descriptor
 *
 * This function constructs a job descriptor capable of performing
 * a key blackening operation on RNG generated.
 *
 * - desc	pointer to a pointer to the descriptor generated by this
 *		function. Caller will be responsible to kfree() this
 *		descriptor after execution.
 * - key	physical pointer to the plaintext, which will also hold
 *		the result. Since encryption occurs in place, caller must
 *              ensure that the space is large enough to accommodate the
 *              blackened key
 * - keysz	size of the plaintext
 * - auth	if a CCM-covered key is required, use KEY_COVER_CCM, else
 *		use KEY_COVER_ECB.
 *
 * Cleanup: The descriptor must be freed
 */
int cnstr_random_black_key_jobdesc(u32 **desc,
				   size_t key_length,
				   caam_dma_addr_t cover_key,
				   size_t cover_key_length,
				   u8 auth, u8 trusted_key)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u16 dsize;
	u32 bk_store;

	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));

	init_job_desc(tmpdesc, CMD_DESC_HDR);

	/* Prepare RNG */
	append_operation(tmpdesc, OP_ALG_ALGSEL_RNG | OP_TYPE_CLASS1_ALG);

	/* Generate RNG and left it in output data fifo */
	append_cmd(tmpdesc, CMD_FIFO_STORE | FIFOST_TYPE_RNGFIFO | key_length);

	/* Copy RNG from outfifo to class 1 Key register */
	append_move(tmpdesc, MOVE_SRC_OUTFIFO | MOVE_DEST_CLASS1KEY |
			MOVE_WAITCOMP | (key_length & MOVE_LEN_MASK));

	/* Write the size of the key moved */
	append_load_imm_u32(tmpdesc, key_length, LDST_CLASS_1_CCB |
			    LDST_SRCDST_WORD_KEYSZ_REG | LDST_IMM);

	bk_store = CLASS_1;
	if (auth == KEY_COVER_ECB)
		bk_store |= FIFOST_TYPE_KEY_KEK;
	else
		bk_store |= FIFOST_TYPE_KEY_CCM_JKEK;

	/* Fifo store to save the key as black key in memory */
	append_fifo_store(tmpdesc, cover_key, cover_key_length, bk_store);

	dsize = desc_bytes(&tmpdesc);

	/* now allocate execution buffer and coat it with executable */
	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return -ENOMEM;

	memcpy(tdesc, tmpdesc, dsize);
	*desc = tdesc;

#ifdef DEBUG
	print_hex_dump(KERN_ERR, "cover random desc:",
		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
#endif

	return 0;
}
EXPORT_SYMBOL(cnstr_random_black_key_jobdesc);

/*
 * Construct a blob encapsulation job descriptor
 *
 * This function dynamically constructs a blob encapsulation job descriptor
 * from the following arguments:
 *
 * - desc	pointer to a pointer to the descriptor generated by this
 *		function. Caller will be responsible to kfree() this
 *		descriptor after execution.
 * - keymod	Physical pointer to a key modifier, which must reside in a
 *		contiguous piece of memory. Modifier will be assumed to be
 *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
 *		for a blob of type DATA_GENMEM (see blobcolor argument).
 * - secretbuf	Physical pointer to a secret, normally a black or red key,
 *		possibly residing within an accessible secure memory page,
 *		of the secret to be encapsulated to an output blob.
 * - outbuf	Physical pointer to the destination buffer to receive the
 *		encapsulated output. This buffer will need to be 48 bytes
 *		larger than the input because of the added encapsulation data.
 *		The generated descriptor will account for the increase in size,
 *		but the caller must also account for this increase in the
 *		buffer allocator.
 * - secretsz	Size of input secret, in bytes. This is limited to 65536
 *		less the size of blob overhead, since the length embeds into
 *		DECO pointer in/out instructions.
 * - keycolor   Determines if the source data is covered (black key) or
 *		plaintext (red key). RED_KEY or BLACK_KEY are defined in
 *		for this purpose.
 * - blobcolor	Determine if encapsulated blob should be a secure memory
 *		blob (DATA_SECMEM), with partition data embedded with key
 *		material, or a general memory blob (DATA_GENMEM).
 * - auth	If BLACK_KEY source is covered via AES-CCM, specify
 *		KEY_COVER_CCM, else uses AES-ECB (KEY_COVER_ECB).
 *
 * Upon completion, desc points to a buffer containing a CAAM job
 * descriptor which encapsulates data into an externally-storable blob
 * suitable for use across power cycles.
 *
 * This is an example of a black key encapsulation job into a general memory
 * blob. Notice the 16-byte key modifier in the LOAD instruction. Also note
 * the output 48 bytes longer than the input:
 *
 * [00] B0800008       jobhdr: stidx=0 len=8
 * [01] 14400010           ld: ccb2-key len=16 offs=0
 * [02] 08144891               ptr->@0x08144891
 * [03] F800003A    seqoutptr: len=58
 * [04] 01000000               out_ptr->@0x01000000
 * [05] F000000A     seqinptr: len=10
 * [06] 09745090               in_ptr->@0x09745090
 * [07] 870D0004    operation: encap blob  reg=memory, black, format=normal
 *
 * This is an example of a red key encapsulation job for storing a red key
 * into a secure memory blob. Note the 8 byte modifier on the 12 byte offset
 * in the LOAD instruction; this accounts for blob permission storage:
 *
 * [00] B0800008       jobhdr: stidx=0 len=8
 * [01] 14400C08           ld: ccb2-key len=8 offs=12
 * [02] 087D0784               ptr->@0x087d0784
 * [03] F8000050    seqoutptr: len=80
 * [04] 09251BB2               out_ptr->@0x09251bb2
 * [05] F0000020     seqinptr: len=32
 * [06] 40000F31               in_ptr->@0x40000f31
 * [07] 870D0008    operation: encap blob  reg=memory, red, sec_mem,
 *                             format=normal
 *
 * Note: this function only generates 32-bit pointers at present, and should
 * be refactored using a scheme that allows both 32 and 64 bit addressing
 */
int cnstr_blob_encap_jobdesc(u32 **desc,
			     caam_dma_addr_t secret, size_t secret_length,
			     u8 keycolor, u8 auth, u8 trusted_key,
			     u8 memtype,
			     caam_dma_addr_t keymod, size_t keymod_length,
			     caam_dma_addr_t blob, size_t blob_length,
			     u8 blobcolor)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u16 dsize, idx;

	/* Trusted key not supported */
	if (trusted_key != UNTRUSTED_KEY)
		return 0;

	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
	idx = 1;

	/*
	 * Key modifier works differently for secure/general memory blobs
	 * This accounts for the permission/protection data encapsulated
	 * within the blob if a secure memory blob is requested
	 */
	if (memtype == DATA_SECMEM)
		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
				 LDST_SRCDST_BYTE_KEY |
				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
				 | (keymod_length & LDST_LEN_MASK);
	else /* is general memory blob */
		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB
				 | LDST_SRCDST_BYTE_KEY
				 | (keymod_length & LDST_LEN_MASK);

	tmpdesc[idx++] = (u32)keymod;

	/*
	 * Encapsulation output must include space for blob key encryption
	 * key and MAC tag
	 */
	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | (secret_length + BLOB_OVERHEAD);
	tmpdesc[idx++] = (u32)blob;

	/* Input data, should be somewhere in secure memory */
	tmpdesc[idx++] = CMD_SEQ_IN_PTR | secret_length;
	tmpdesc[idx++] = (uintptr_t)secret;

	/* Set blob encap, then color */
	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_ENCAP_PROTOCOL | OP_PCLID_BLOB;

	if (memtype == DATA_SECMEM)
		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;

	if (auth == KEY_COVER_CCM)
		tmpdesc[idx] |= OP_PCL_BLOB_EKT;

	/* An input black key cannot be stored in a red blob */
	if (keycolor == BLACK_KEY)
		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;

	idx++;
	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
	dsize = idx * sizeof(u32);

	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return 0;

	memcpy(tdesc, tmpdesc, dsize);
	*desc = tdesc;

#ifdef DEBUG
	print_hex_dump(KERN_ERR, "encap desc:",
		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
#endif

	return dsize;
}
EXPORT_SYMBOL(cnstr_blob_encap_jobdesc);

/*
 * Construct a blob decapsulation job descriptor
 *
 * This function dynamically constructs a blob decapsulation job descriptor
 * from the following arguments:
 *
 * - desc	pointer to a pointer to the descriptor generated by this
 *		function. Caller will be responsible to kfree() this
 *		descriptor after execution.
 * - keymod	Physical pointer to a key modifier, which must reside in a
 *		contiguous piece of memory. Modifier will be assumed to be
 *		8 bytes long for a blob of type DATA_SECMEM, or 16 bytes long
 *		for a blob of type DATA_GENMEM (see blobcolor argument).
 * - blobbuf	Physical pointer (into external memory) of the blob to
 *		be decapsulated. Blob must reside in a contiguous memory
 *		segment.
 * - outbuf	Physical pointer of the decapsulated output, possibly into
 *		a location within a secure memory page. Must be contiguous.
 * - secretsz	Size of encapsulated secret in bytes (not the size of the
 *		input blob).
 * - keycolor   Determines if decapsulated content is encrypted (BLACK_KEY)
 *		or left as plaintext (RED_KEY).
 * - blobcolor	Determine if encapsulated blob should be a secure memory
 *		blob (DATA_SECMEM), with partition data embedded with key
 *		material, or a general memory blob (DATA_GENMEM).
 * - auth	If decapsulation path is specified by BLACK_KEY, then if
 *		AES-CCM is requested for key covering use KEY_COVER_CCM, else
 *		use AES-ECB (KEY_COVER_ECB).
 *
 * Upon completion, desc points to a buffer containing a CAAM job descriptor
 * that decapsulates a key blob from external memory into a black (encrypted)
 * key or red (plaintext) content.
 *
 * This is an example of a black key decapsulation job from a general memory
 * blob. Notice the 16-byte key modifier in the LOAD instruction.
 *
 * [00] B0800008       jobhdr: stidx=0 len=8
 * [01] 14400010           ld: ccb2-key len=16 offs=0
 * [02] 08A63B7F               ptr->@0x08a63b7f
 * [03] F8000010    seqoutptr: len=16
 * [04] 01000000               out_ptr->@0x01000000
 * [05] F000003A     seqinptr: len=58
 * [06] 01000010               in_ptr->@0x01000010
 * [07] 860D0004    operation: decap blob  reg=memory, black, format=normal
 *
 * This is an example of a red key decapsulation job for restoring a red key
 * from a secure memory blob. Note the 8 byte modifier on the 12 byte offset
 * in the LOAD instruction:
 *
 * [00] B0800008       jobhdr: stidx=0 len=8
 * [01] 14400C08           ld: ccb2-key len=8 offs=12
 * [02] 01000000               ptr->@0x01000000
 * [03] F8000020    seqoutptr: len=32
 * [04] 400000E6               out_ptr->@0x400000e6
 * [05] F0000050     seqinptr: len=80
 * [06] 08F0C0EA               in_ptr->@0x08f0c0ea
 * [07] 860D0008    operation: decap blob  reg=memory, red, sec_mem,
 *			       format=normal
 *
 * Note: this function only generates 32-bit pointers at present, and should
 * be refactored using a scheme that allows both 32 and 64 bit addressing
 */
int cnstr_blob_decap_jobdesc(u32 **desc,
			     caam_dma_addr_t blob, size_t blob_length,
			     u8 blobcolor,
			     caam_dma_addr_t keymod, size_t keymod_length,
			     caam_dma_addr_t secret, size_t secret_length,
			     u8 keycolor, u8 auth,  u8 trusted_key,
			     u8 memtype)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u16 dsize, idx;

	/* Trusted key not supported */
	if (trusted_key != UNTRUSTED_KEY)
		return 0;

	memset(tmpdesc, 0, ARRAY_SIZE(tmpdesc) * sizeof(u32));
	idx = 1;

	/* Load key modifier */
	if (memtype == DATA_SECMEM)
		tmpdesc[idx++] = CMD_LOAD | LDST_CLASS_2_CCB |
				 LDST_SRCDST_BYTE_KEY |
				 ((12 << LDST_OFFSET_SHIFT) & LDST_OFFSET_MASK)
				 | (keymod_length & LDST_LEN_MASK);
	else /* is general memory blob */
		tmpdesc[idx++] = CMD_LOAD
				| LDST_CLASS_2_CCB
				| LDST_SRCDST_BYTE_KEY
				| (keymod_length & LDST_LEN_MASK);

	tmpdesc[idx++] = (u32)keymod;

	/* Compensate BKEK + MAC tag over size of encapsulated secret */
	tmpdesc[idx++] = CMD_SEQ_IN_PTR | blob_length;
	tmpdesc[idx++] = (u32)blob;
	tmpdesc[idx++] = CMD_SEQ_OUT_PTR | secret_length;
	tmpdesc[idx++] = (uintptr_t)secret;

	/* Decapsulate from secure memory partition to black blob */
	tmpdesc[idx] = CMD_OPERATION | OP_TYPE_DECAP_PROTOCOL | OP_PCLID_BLOB;

	if (memtype == DATA_SECMEM)
		tmpdesc[idx] |= OP_PCL_BLOB_PTXT_SECMEM;

	if (auth == KEY_COVER_CCM)
		tmpdesc[idx] |= OP_PCL_BLOB_EKT;

	if (keycolor == BLACK_KEY)
		tmpdesc[idx] |= OP_PCL_BLOB_BLACK;

	idx++;
	tmpdesc[0] = CMD_DESC_HDR | HDR_ONE | (idx & HDR_DESCLEN_MASK);
	dsize = idx * sizeof(u32);

	tdesc = kmalloc(dsize, GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return 0;

	memcpy(tdesc, tmpdesc, dsize);
	*desc = tdesc;

#ifdef DEBUG
	print_hex_dump(KERN_ERR, "decap desc:",
		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
#endif

	return dsize;
}
EXPORT_SYMBOL(cnstr_blob_decap_jobdesc);

/*
 * @brief      Create a job descriptor to load a key by address
 *
 * @param[out] desc        The description
 * @param[in]  key         The key
 * @param[in]  key_size    The key size
 * @param[in]  key_length  The key length
 * @param[in]  key_class   The key class
 * @param[in]  enc         The encode
 * @param[in]  nwb         The nwb
 * @param[in]  ekt         The ekt
 * @param[in]  kdest       The kdest
 *
 * @return     Return the number of bytes of the descriptor
 */
int cnstr_key_jobdesc(u32 **desc,
		      caam_dma_addr_t key, size_t key_size, size_t key_length,
		      u32 key_class, u32 enc,
		      u32 nwb, u32 ekt, u32 kdest)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u32 key_option;

	init_desc(tmpdesc, CMD_DESC_HDR);

	key_option = key_class | enc | nwb | ekt | kdest;

	if (enc)
		append_key(tmpdesc, key, key_length, key_option);
	else
		append_key(tmpdesc, key, key_size, key_option);

	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return 0;

	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
	*desc = tdesc;

#ifdef DEBUG
	print_hex_dump(KERN_ERR, "key desc:",
		       DUMP_PREFIX_OFFSET, 16, 4, *desc, desc_bytes(*desc), 0);
#endif

	return desc_bytes(tmpdesc);
}
EXPORT_SYMBOL(cnstr_key_jobdesc);

/**
 * @brief      Create a job descriptor to load an immediate key
 *
 * @param[out] desc        The description
 * @param[in]  key         The key
 * @param[in]  key_size    The key size
 * @param[in]  key_length  The key length
 * @param[in]  key_class   The key class
 * @param[in]  enc         The encode
 * @param[in]  nwb         The nwb
 * @param[in]  ekt         The ekt
 * @param[in]  kdest       The kdest
 *
 * @return     Return the number of bytes of the descriptor
 */
int cnstr_key_imm_jobdesc(u32 **desc,
			  void *key, size_t key_size, size_t key_length,
			  u32 key_class, u32 enc,
			  u32 nwb, u32 ekt, u32 kdest)
{
	u32 *tdesc, tmpdesc[INITIAL_DESCSZ];
	u32 key_option;

	init_desc(tmpdesc, CMD_DESC_HDR);

	key_option = key_class | enc | nwb | ekt | kdest;

	append_key_as_imm(tmpdesc, (void *)key, key_size, key_length,
			  key_option);

	tdesc = kmalloc(desc_bytes(tmpdesc), GFP_KERNEL | GFP_DMA);
	if (!tdesc)
		return 0;

	memcpy(tdesc, tmpdesc, desc_bytes(tmpdesc));
	*desc = tdesc;

	return desc_bytes(tmpdesc);
}
EXPORT_SYMBOL(cnstr_key_imm_jobdesc);
